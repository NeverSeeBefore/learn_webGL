<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图像的缩放</title>
</head>

<body>
    <canvas width="500px" height="500px" id="oCanvas"></canvas>
    <script>
        var oCanvas = document.getElementById('oCanvas');
        // 1. 获取上线文对象
        // experimental-webgl  / webgl
        var gl = oCanvas.getContext('webgl');
        // 2. 初始化着色器

        // 2.1 初始化顶点着色器和片元着色器 代码
        // vec2 代表点 有两个分量 x, y
        // vec3 代表向量 有三个分量 x, y
        // 三维坐标系上的点 A（x, y, z）
        // 在齐次坐标系中 使用（x, y, z, w） 表示这个顶点
        // 使用（x, y, z, 0） 表示向量
        // vec4(x, y, z, w)  齐次坐标系(n维的向量用一个n+1维向量)（区分是点还是矢量）
        var vertexStr = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            varying vec4 v_color;
            /* 创建缩放矩阵 */
            uniform mat4 u_scaleMatrix;
            void main () {
                gl_Position = u_scaleMatrix * a_position;
                gl_PointSize = 10.0;
                v_color = a_color;
            }`;
        var fragmentStr = `
            precision mediump float;
            varying vec4 v_color;
            void main () {
                gl_FragColor = v_color;
            }`;
        // 2.2 创建着色器
        var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexStr)
        var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentStr)

        // 2.3 创建着色器程序
        var program = createProgram(gl, vertexShader, fragmentShader);

        gl.useProgram(program);
        // 3. 绘制图形

        var a_position = gl.getAttribLocation(program, 'a_position');
        var a_color = gl.getAttribLocation(program, 'a_color');
        var u_scaleMatrix = gl.getUniformLocation(program, 'u_scaleMatrix');

        var scaleX = 1;
        var scaleY = 0.5;
        var scaleZ = 1;
        gl.uniformMatrix4fv(u_scaleMatrix, false, new Float32Array([
            scaleX, 0,      0,      0,
            0,      scaleY, 0,      0,
            0,      0,      scaleZ, 0,
            0,      0,      0,      1
        ]))

        // 01 创建缓冲区
        var positionBuffer = gl.createBuffer();
        var indexBuffer = gl.createBuffer();

        // 02 绑定缓冲区
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // 03 设置缓冲区数据
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                -0.5, 0.5, 0, 1, 1, 0,
                -0.5, -0.5, 0, 0, 0, 1,
                0.5, -0.5, 0, 1, 0, 1,
                -0.5, 0.5, 0, 0, 0, 1,
                0.5, -0.5, 0, 1, 0, 1,
                0.5, 0.5, 0, 1, 0, 1,
            ]),
            gl.STATIC_DRAW
        );
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array([
            ]),
            gl.STATIC_DRAW
        );

        // 04 设置属性取值方式
        // 位置， 每个顶点的分量个数， 数据类型， 是否归一化， 两个顶点间的字节数， 偏移量
        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 4 * 6, 4 * 3);

        // 05 启用属性从缓冲区中取值
        gl.enableVertexAttribArray(a_position);
        gl.enableVertexAttribArray(a_color);

        // 06 绘制
        gl.drawArrays(gl.TRIANGLES, 0, 6);





        function createShader(gl, type, source) {
            // 创建着色器
            var shader = gl.createShader(type);
            // 想着色器中添加资源
            gl.shaderSource(shader, source);
            // 编译资源
            gl.compileShader(shader);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                console.log('创建着色器失败', success, gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            // 创建程序
            var program = gl.createProgram();
            // 绑定着色器
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            // 连接着色器程序
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                console.log('创建程序失败', success, gl.getProgramInfoLog(program));
            }
            return program;
        }








        // sin(a + b) = sin(a)cos(b) + cos(a)sin(b);
        // sin(a - b) = sin(a)cos(b) - cos(a)sin(b);
        // cos(a + b) = cos(a)cos(b) - sin(a)sin(b);
        // cos(a - b) = cos(a)cos(b) + sin(a)sin(b);

        // 旋转矩阵 由三角函数推理得来
        // {        {                       {
        // x'       cosB    -sinB   0       x
        // y'   =   sinB    cosB    0   *   y
        // z'       0       0       1       z
        // }        }                       }

        // 平移矩阵
        // {        {                       {
        // x'       1    0   0  TX       x
        // y'   =   0    1   0  TY   *   y
        // z'       0    0   1  TZ       z
        // }        }                       }

        // 缩放矩阵
        // {        {                       {
        // x'       SX   0   0       x
        // y'   =   0    SY  0   *   y
        // z'       0    0   SZ      z
        // }        }                       }
    </script>
</body>

</html>